{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Educ - Apenas mais uma plataforma de ensino \u00b6 Oi! Me chamo Luiz e sou Cloud Engineer na Umbler e professor na IENH no curso T\u00e9cnico em Inform\u00e1tica e no superior de Redes de Computadores. Criei este espa\u00e7o para adicionar \"a parte te\u00f3rica\" que desenvolvo nas minhas aulas. Todos os documentos contidos aqui devem ser considerados sob a licen\u00e7a Creative Commons Atribui\u00e7\u00e3o-CompartilhaIgual 4.0 Internacional . Conte\u00fados disponibilizados \u00b6 .NET Core - B\u00e1sico .NET Core - Orienta\u00e7\u00e3o a Objetos","title":"Educ - Apenas mais uma plataforma de ensino"},{"location":"#educ-apenas-mais-uma-plataforma-de-ensino","text":"Oi! Me chamo Luiz e sou Cloud Engineer na Umbler e professor na IENH no curso T\u00e9cnico em Inform\u00e1tica e no superior de Redes de Computadores. Criei este espa\u00e7o para adicionar \"a parte te\u00f3rica\" que desenvolvo nas minhas aulas. Todos os documentos contidos aqui devem ser considerados sob a licen\u00e7a Creative Commons Atribui\u00e7\u00e3o-CompartilhaIgual 4.0 Internacional .","title":"Educ - Apenas mais uma plataforma de ensino"},{"location":"#conteudos-disponibilizados","text":".NET Core - B\u00e1sico .NET Core - Orienta\u00e7\u00e3o a Objetos","title":"Conte\u00fados disponibilizados"},{"location":"dotnet/basics/","text":".NET Core - B\u00e1sico \u00b6 Este conte\u00fado tem a ideia de fixar o conhecimento de algoritmos usando a linguagem C# com uso do .NET Core. Lembrando que um algoritmo \u00e9 uma sequencia de passos finitos com objetivo de resolver um problema. E com isso usamos a l\u00f3gica de programa\u00e7\u00e3o (uma t\u00e9cnica de encadear pensamentos para atingir determinado objetivo) para resolver estes problemas 1 . O que \u00e9 o .NET Core \u00b6 O .NET \u00e9 uma plataforma de desenvolvedor de c\u00f3digo aberto e cross-platform para a cria\u00e7\u00e3o de v\u00e1rios tipos diferentes de aplicativos. Com o .NET, voc\u00ea pode usar v\u00e1rias linguagens, editores e bibliotecas para criar web, mobile, desktop, jogos e IoT (internet das coisas) 2 . Para utilizar a plataforma .NET precisamos utilizar uma linguagem de programa\u00e7\u00e3o, e neste caso vamos utilizar o C#, que \u00e9 uma linguagem de programa\u00e7\u00e3o simples, moderna, orientada a objetos e de tipagem segura. Alem da linguagem, vamos utilizar uma implementa\u00e7\u00e3o do .NET cross-platform para sites, servidores e aplicativos de console para Linux, Windows e macOS, isto \u00e9, o .NET Core 2 . Ambiente para desenvolvimento \u00b6 Para o desenvolvimento de aplica\u00e7\u00f5es com uso do .NET Core ser\u00e1 necess\u00e1rio montar um ambiente de desenvolvimento. O ambiente que recomendo pode ser instalado em ambientes com os seguintes sistemas operacionais: Windows, Linux ou Mac. Visual Studio Code .NET Core SDK Git Antes de continuar a leitura e executar os exemplos, instale os programas listados acima. Mais que um Hello World (Ol\u00e1 Mundo) \u00b6 Quando falamos de come\u00e7ar com qualquer linguagem de programa\u00e7\u00e3o, falamos de fazer o tal do \" Hello World \", que se baseia em fazer um programa que escreva na tela ou em um navegador a frase: \" Hello World \" ou em portugu\u00eas: \"Ol\u00e1 Mundo\". Vamos fazer o nosso? Abra o prompt de comando (no windows) ou o terminal (Linux / Mac) e crie uma pasta chamada HelloWorld e entre nela. Dentro da pasta, execute este comando: dotnet new console Ap\u00f3s algumas mensagens, voc\u00ea deve ter na pasta alguns arquivos. Com estes arquivos na pasta, execute este comando: dotnet run Dever\u00e1 escrever na tela \" Hello world \". Brotip : Se voc\u00ea n\u00e3o sabe usar o prompt de comando, veja este link e se voc\u00ea n\u00e3o sabe usar o terminal, conhe\u00e7a aqui os comandos , que tamb\u00e9m funcionam no Mac. Pronto! Fizemos nosso \" Hello World \"! F\u00e1cil n\u00e3o? F\u00e1cil at\u00e9 de mais n\u00e9? N\u00e3o precisamos fazer nada alem de comandos! Por isso que esta sess\u00e3o se chama: \"Mais que um Hello World (Ol\u00e1 Mundo)\". \ud83d\ude1d Agora vamos conhecer nossos arquivos! Para isso vamos abrir esta pasta no Visual Studio Code, executando o comando dentro da mesma pasta: code . (Sim, esse ponto final precisa estar junto). Vamos nos ater a estrutura deste projeto (vamos come\u00e7ar a chamar essas pastas que criamos e rodamos o dotnet new console de projetos, ok?): bin : Pasta onde ficam os arquivos que s\u00e3o compilados pelo .NET Core. obj : Pasta onde ficam os arquivos intermedi\u00e1rios da compila\u00e7\u00e3o. HelloWorld.csproj : Este \u00e9 o arquivo de projeto que \u00e9 especificados os par\u00e2metros que ser\u00e3o usados pelo compilador. Program.cs : Este \u00e9 o arquivo com o c\u00f3digo fonte do nosso programa. Atualmente o arquivo mais importante e que ser\u00e1 sempre o mesmo arquivo utilizado em nossos projetos \u00e9 o Program.cs e o seu conte\u00fado \u00e9 apresentado abaixo: using System ; namespace HelloWorld { class Program { static void Main ( string [] args ) { Console . WriteLine ( \"Hello World!\" ); } } } Vamos entender \"linha a linha\" o que esta neste arquivo: using System ; Aqui est\u00e1 carregando uma biblioteca de comandos, e neste caso, esta carregando uma biblioteca com fun\u00e7\u00f5es de sistema. namespace HelloWorld { } Esta \u00e9 o espa\u00e7o virtual do programa, tudo que \u00e9 desenvolvido dentro deste espa\u00e7o \u00e9 considerado compartilhado pelo programa. Nos exemplos b\u00e1sicos que abordaremos aqui sempre utilizaremos o mesmo nome e ser\u00e1 o mesmo nome do projeto. class Program { } Esta \u00e9 a classe base do programa. Classe ser\u00e1 algo abordado em Orienta\u00e7\u00e3o a Objetos , mas no momento temos que ter em mente que esta \u00e9 a classe que o programa executa o objeto principal chamado Program . static void Main(string[] args) { } Este \u00e9 o m\u00e9todo principal da classe Program . De maneira b\u00e1sica, aqui \u00e9 onde fica o nossos c\u00f3digos que ir\u00e3o ser executados pelo programa. \u00c9 outro assunto que ser\u00e1 abordado em Orienta\u00e7\u00e3o a Objetos . Console . WriteLine ( \"Hello World!\" ); E por fim e n\u00e3o menos importante! Aqui temos o nosso c\u00f3digo que foi executado quando rodamos o dotnet run . O Console \u00e9 o objeto que representa o Prompt de Comando ou o Terminal, e ele esta executando um m\u00e9todo chamado WriteLine() , que serve para imprimir no Prompt de Comando ou Terminal a string que estiver digitada dentro dos parenteses. Veja mais \u00b6 Vari\u00e1veis Operadores Condicionais Repeti\u00e7\u00f5es Vetores Introdu\u00e7\u00e3o \u00e0 programa\u00e7\u00e3o: 500 algoritmos resolvidos \u21a9 What is .NET? \u21a9 \u21a9","title":".NET Core - B\u00e1sico"},{"location":"dotnet/basics/#net-core-basico","text":"Este conte\u00fado tem a ideia de fixar o conhecimento de algoritmos usando a linguagem C# com uso do .NET Core. Lembrando que um algoritmo \u00e9 uma sequencia de passos finitos com objetivo de resolver um problema. E com isso usamos a l\u00f3gica de programa\u00e7\u00e3o (uma t\u00e9cnica de encadear pensamentos para atingir determinado objetivo) para resolver estes problemas 1 .","title":".NET Core - B\u00e1sico"},{"location":"dotnet/basics/#o-que-e-o-net-core","text":"O .NET \u00e9 uma plataforma de desenvolvedor de c\u00f3digo aberto e cross-platform para a cria\u00e7\u00e3o de v\u00e1rios tipos diferentes de aplicativos. Com o .NET, voc\u00ea pode usar v\u00e1rias linguagens, editores e bibliotecas para criar web, mobile, desktop, jogos e IoT (internet das coisas) 2 . Para utilizar a plataforma .NET precisamos utilizar uma linguagem de programa\u00e7\u00e3o, e neste caso vamos utilizar o C#, que \u00e9 uma linguagem de programa\u00e7\u00e3o simples, moderna, orientada a objetos e de tipagem segura. Alem da linguagem, vamos utilizar uma implementa\u00e7\u00e3o do .NET cross-platform para sites, servidores e aplicativos de console para Linux, Windows e macOS, isto \u00e9, o .NET Core 2 .","title":"O que \u00e9 o .NET Core"},{"location":"dotnet/basics/#ambiente-para-desenvolvimento","text":"Para o desenvolvimento de aplica\u00e7\u00f5es com uso do .NET Core ser\u00e1 necess\u00e1rio montar um ambiente de desenvolvimento. O ambiente que recomendo pode ser instalado em ambientes com os seguintes sistemas operacionais: Windows, Linux ou Mac. Visual Studio Code .NET Core SDK Git Antes de continuar a leitura e executar os exemplos, instale os programas listados acima.","title":"Ambiente para desenvolvimento"},{"location":"dotnet/basics/#mais-que-um-hello-world-ola-mundo","text":"Quando falamos de come\u00e7ar com qualquer linguagem de programa\u00e7\u00e3o, falamos de fazer o tal do \" Hello World \", que se baseia em fazer um programa que escreva na tela ou em um navegador a frase: \" Hello World \" ou em portugu\u00eas: \"Ol\u00e1 Mundo\". Vamos fazer o nosso? Abra o prompt de comando (no windows) ou o terminal (Linux / Mac) e crie uma pasta chamada HelloWorld e entre nela. Dentro da pasta, execute este comando: dotnet new console Ap\u00f3s algumas mensagens, voc\u00ea deve ter na pasta alguns arquivos. Com estes arquivos na pasta, execute este comando: dotnet run Dever\u00e1 escrever na tela \" Hello world \". Brotip : Se voc\u00ea n\u00e3o sabe usar o prompt de comando, veja este link e se voc\u00ea n\u00e3o sabe usar o terminal, conhe\u00e7a aqui os comandos , que tamb\u00e9m funcionam no Mac. Pronto! Fizemos nosso \" Hello World \"! F\u00e1cil n\u00e3o? F\u00e1cil at\u00e9 de mais n\u00e9? N\u00e3o precisamos fazer nada alem de comandos! Por isso que esta sess\u00e3o se chama: \"Mais que um Hello World (Ol\u00e1 Mundo)\". \ud83d\ude1d Agora vamos conhecer nossos arquivos! Para isso vamos abrir esta pasta no Visual Studio Code, executando o comando dentro da mesma pasta: code . (Sim, esse ponto final precisa estar junto). Vamos nos ater a estrutura deste projeto (vamos come\u00e7ar a chamar essas pastas que criamos e rodamos o dotnet new console de projetos, ok?): bin : Pasta onde ficam os arquivos que s\u00e3o compilados pelo .NET Core. obj : Pasta onde ficam os arquivos intermedi\u00e1rios da compila\u00e7\u00e3o. HelloWorld.csproj : Este \u00e9 o arquivo de projeto que \u00e9 especificados os par\u00e2metros que ser\u00e3o usados pelo compilador. Program.cs : Este \u00e9 o arquivo com o c\u00f3digo fonte do nosso programa. Atualmente o arquivo mais importante e que ser\u00e1 sempre o mesmo arquivo utilizado em nossos projetos \u00e9 o Program.cs e o seu conte\u00fado \u00e9 apresentado abaixo: using System ; namespace HelloWorld { class Program { static void Main ( string [] args ) { Console . WriteLine ( \"Hello World!\" ); } } } Vamos entender \"linha a linha\" o que esta neste arquivo: using System ; Aqui est\u00e1 carregando uma biblioteca de comandos, e neste caso, esta carregando uma biblioteca com fun\u00e7\u00f5es de sistema. namespace HelloWorld { } Esta \u00e9 o espa\u00e7o virtual do programa, tudo que \u00e9 desenvolvido dentro deste espa\u00e7o \u00e9 considerado compartilhado pelo programa. Nos exemplos b\u00e1sicos que abordaremos aqui sempre utilizaremos o mesmo nome e ser\u00e1 o mesmo nome do projeto. class Program { } Esta \u00e9 a classe base do programa. Classe ser\u00e1 algo abordado em Orienta\u00e7\u00e3o a Objetos , mas no momento temos que ter em mente que esta \u00e9 a classe que o programa executa o objeto principal chamado Program . static void Main(string[] args) { } Este \u00e9 o m\u00e9todo principal da classe Program . De maneira b\u00e1sica, aqui \u00e9 onde fica o nossos c\u00f3digos que ir\u00e3o ser executados pelo programa. \u00c9 outro assunto que ser\u00e1 abordado em Orienta\u00e7\u00e3o a Objetos . Console . WriteLine ( \"Hello World!\" ); E por fim e n\u00e3o menos importante! Aqui temos o nosso c\u00f3digo que foi executado quando rodamos o dotnet run . O Console \u00e9 o objeto que representa o Prompt de Comando ou o Terminal, e ele esta executando um m\u00e9todo chamado WriteLine() , que serve para imprimir no Prompt de Comando ou Terminal a string que estiver digitada dentro dos parenteses.","title":"Mais que um Hello World (Ol\u00e1 Mundo)"},{"location":"dotnet/basics/#veja-mais","text":"Vari\u00e1veis Operadores Condicionais Repeti\u00e7\u00f5es Vetores Introdu\u00e7\u00e3o \u00e0 programa\u00e7\u00e3o: 500 algoritmos resolvidos \u21a9 What is .NET? \u21a9 \u21a9","title":"Veja mais"},{"location":"dotnet/basics/arrays/","text":"Vetores \u00b6 Vimos em Variaveis que elas s\u00e3o uma \u00e1rea de mem\u00f3ria tempor\u00e1ria onde podemos armazenar um determinado dado enquanto o programa esta sendo executado. Um vetor \u00e9 um tipo especial de vari\u00e1vel, que pode receber um conjunto de vari\u00e1veis em uma mesma vari\u00e1vel 1 . Por exemplo, se queremos uma vari\u00e1vel inteira, declaramos assim: // declarando uma vari\u00e1vel inteiro \"numero\" e colocamos o n\u00famero 3 nela int numero = 3 ; Agora com um vetor, podemos declarar um conjunto de vari\u00e1veis inteiras, assim: // declarando um vetor de inteiros \"numeros\" e colocamos os n\u00fameros 1, 2 e 3 nele int [] numeros = new int [ 3 ] { 1 , 2 , 3 }; Vetores s\u00e3o muito usados para resolver problemas que envolvem uma manipula\u00e7\u00e3o de dados quando estamos em uma repeti\u00e7\u00e3o , por exemplo. Vamos a um problema para resolver: Desenvolver um programa que leia 5 n\u00fameros inteiros e imprima o menor e o maior n\u00famero. Vamos ver o c\u00f3digo e sua execu\u00e7\u00e3o: using System ; namespace MenorMaior { class Program { static void Main ( string [] args ) { // Instanciando o vetor para receber 5 n\u00fameros int [] numeros = new int [ 5 ]; // Criando um la\u00e7o (repeti\u00e7\u00e3o) lendo de 0 (primeira \"vaga\" do vetor) // at\u00e9 4 (\u00faltima \"vaga\" do vetor) for ( int i = 0 ; i < numeros . Length ; i ++) { // Um condicional para personalizar as mensagens! // \"Balaca\"? Sim, mas fica mais divertido assim! if ( i == 0 ) { Console . Write ( \"Digite um n\u00famero: \" ); } else { Console . Write ( \"Digite outro n\u00famero: \" ); } numeros [ i ] = int . Parse ( Console . ReadLine ()); } // Bom, eu n\u00e3o sei quem \u00e9 o maior ou o menor, mas posso // come\u00e7ar imaginando que \u00e9 sempre a primeira posi\u00e7\u00e3o do vetor! int menor = numeros [ 0 ], maior = numeros [ 0 ]; // Precisamos ler novamente o vetor para descobrir quem \u00e9 // o menor e maior. Porque iniciando no \"1\"? Porque o // \"0\" j\u00e1 esta testado ali em cima n\u00e9? for ( int i = 1 ; i < numeros . Length ; i ++) { // Testando o menor if ( menor > numeros [ i ]) { menor = numeros [ i ]; } // Testando o maior if ( maior < numeros [ i ]) { maior = numeros [ i ]; } } // Quando acabar tudo, temos o menor e o maior! Console . WriteLine ( \"O menor n\u00famero digitado \u00e9: \" + menor ); Console . WriteLine ( \"O maior n\u00famero digitado \u00e9: \" + maior ); } } } A execu\u00e7\u00e3o do c\u00f3digo deve funcionar assim: Atribui\u00e7\u00e3o de dados em um vetor \u00b6 Como vimos no nosso problema-exemplo, a atribui\u00e7\u00e3o \u00e9 feita com o nome da vari\u00e1vel e no final entre colchetes, o n\u00famero da posi\u00e7\u00e3o que queremos do vetor, lembrando que ele come\u00e7a em \"0\" e termina em \"tamanho do vetor subtra\u00eddo 1\". Um exemplo de atribui\u00e7\u00e3o: int [] numeros = new int [ 3 ]; numeros [ 0 ] = 2 ; // Primeiro numeros [ 1 ] = 5 ; numeros [ 2 ] = 0 ; // \u00daltimo Aqui temos a forma mais b\u00e1sica do uso de vetores, e existem mais tipos de vetores que podem ser estudados 1 . C# 7 Quick Syntax Reference: A Pocket Guide to the Language, APIs, and Library \u21a9 \u21a9","title":"Vetores"},{"location":"dotnet/basics/arrays/#vetores","text":"Vimos em Variaveis que elas s\u00e3o uma \u00e1rea de mem\u00f3ria tempor\u00e1ria onde podemos armazenar um determinado dado enquanto o programa esta sendo executado. Um vetor \u00e9 um tipo especial de vari\u00e1vel, que pode receber um conjunto de vari\u00e1veis em uma mesma vari\u00e1vel 1 . Por exemplo, se queremos uma vari\u00e1vel inteira, declaramos assim: // declarando uma vari\u00e1vel inteiro \"numero\" e colocamos o n\u00famero 3 nela int numero = 3 ; Agora com um vetor, podemos declarar um conjunto de vari\u00e1veis inteiras, assim: // declarando um vetor de inteiros \"numeros\" e colocamos os n\u00fameros 1, 2 e 3 nele int [] numeros = new int [ 3 ] { 1 , 2 , 3 }; Vetores s\u00e3o muito usados para resolver problemas que envolvem uma manipula\u00e7\u00e3o de dados quando estamos em uma repeti\u00e7\u00e3o , por exemplo. Vamos a um problema para resolver: Desenvolver um programa que leia 5 n\u00fameros inteiros e imprima o menor e o maior n\u00famero. Vamos ver o c\u00f3digo e sua execu\u00e7\u00e3o: using System ; namespace MenorMaior { class Program { static void Main ( string [] args ) { // Instanciando o vetor para receber 5 n\u00fameros int [] numeros = new int [ 5 ]; // Criando um la\u00e7o (repeti\u00e7\u00e3o) lendo de 0 (primeira \"vaga\" do vetor) // at\u00e9 4 (\u00faltima \"vaga\" do vetor) for ( int i = 0 ; i < numeros . Length ; i ++) { // Um condicional para personalizar as mensagens! // \"Balaca\"? Sim, mas fica mais divertido assim! if ( i == 0 ) { Console . Write ( \"Digite um n\u00famero: \" ); } else { Console . Write ( \"Digite outro n\u00famero: \" ); } numeros [ i ] = int . Parse ( Console . ReadLine ()); } // Bom, eu n\u00e3o sei quem \u00e9 o maior ou o menor, mas posso // come\u00e7ar imaginando que \u00e9 sempre a primeira posi\u00e7\u00e3o do vetor! int menor = numeros [ 0 ], maior = numeros [ 0 ]; // Precisamos ler novamente o vetor para descobrir quem \u00e9 // o menor e maior. Porque iniciando no \"1\"? Porque o // \"0\" j\u00e1 esta testado ali em cima n\u00e9? for ( int i = 1 ; i < numeros . Length ; i ++) { // Testando o menor if ( menor > numeros [ i ]) { menor = numeros [ i ]; } // Testando o maior if ( maior < numeros [ i ]) { maior = numeros [ i ]; } } // Quando acabar tudo, temos o menor e o maior! Console . WriteLine ( \"O menor n\u00famero digitado \u00e9: \" + menor ); Console . WriteLine ( \"O maior n\u00famero digitado \u00e9: \" + maior ); } } } A execu\u00e7\u00e3o do c\u00f3digo deve funcionar assim:","title":"Vetores"},{"location":"dotnet/basics/arrays/#atribuicao-de-dados-em-um-vetor","text":"Como vimos no nosso problema-exemplo, a atribui\u00e7\u00e3o \u00e9 feita com o nome da vari\u00e1vel e no final entre colchetes, o n\u00famero da posi\u00e7\u00e3o que queremos do vetor, lembrando que ele come\u00e7a em \"0\" e termina em \"tamanho do vetor subtra\u00eddo 1\". Um exemplo de atribui\u00e7\u00e3o: int [] numeros = new int [ 3 ]; numeros [ 0 ] = 2 ; // Primeiro numeros [ 1 ] = 5 ; numeros [ 2 ] = 0 ; // \u00daltimo Aqui temos a forma mais b\u00e1sica do uso de vetores, e existem mais tipos de vetores que podem ser estudados 1 . C# 7 Quick Syntax Reference: A Pocket Guide to the Language, APIs, and Library \u21a9 \u21a9","title":"Atribui\u00e7\u00e3o de dados em um vetor"},{"location":"dotnet/basics/conditionals/","text":"Condicionais \u00b6 Os condicionais s\u00e3o momentos de decis\u00e3o em um programa onde ele pode ou n\u00e3o executar um peda\u00e7o do c\u00f3digo 1 . Esta decis\u00e3o pode ser desenvolvida de duas formas: If/else/else if (Se/sen\u00e3o/sen\u00e3o se) Switch case (Em caso de) If/else/else if \u00b6 Utilizando este tipo de condicional, o que define a decis\u00e3o \u00e9 um teste onde a resposta precisa ser booleano, isto \u00e9, precisa retornar verdadeiro ou falso. Ent\u00e3o vamos a mais um problema que temos que resolver desenvolvendo um programa em C#: Criar um programa que calcule a m\u00e9dia aritm\u00e9tica de duas notas (n\u00fameros inteiros) de um aluno e imprima a m\u00e9dia e se esta m\u00e9dia for maior ou igual a 6 imprimir \"aprovado\". O c\u00f3digo ficaria mais ou menos assim: using System ; namespace CalculaMedia { class Program { static void Main ( string [] args ) { Console . Write ( \"Digite a primeira nota do aluno: \" ); int nota1 = int . Parse ( Console . ReadLine ()); Console . Write ( \"Digite a segunda nota do aluno: \" ); int nota2 = int . Parse ( Console . ReadLine ()); int media = ( nota1 + nota2 ) / 2 ; Console . WriteLine ( \"A m\u00e9dia do aluno \u00e9 \" + media ); if ( media >= 6 ) { Console . WriteLine ( \"O aluno esta aprovado!\" ); } } } } Adicionando uma regra nova: O programa precisa retornar alem de \"aprovado\" quando for maior ou igual a 6 a nota, deve retornar \"reprovado\" quando for o contrario. Para isso vamos fazer as modifica\u00e7\u00f5es: using System ; namespace CalculaMedia { class Program { static void Main ( string [] args ) { Console . Write ( \"Digite a primeira nota do aluno: \" ); int nota1 = int . Parse ( Console . ReadLine ()); Console . Write ( \"Digite a segunda nota do aluno: \" ); int nota2 = int . Parse ( Console . ReadLine ()); int media = ( nota1 + nota2 ) / 2 ; Console . WriteLine ( \"A m\u00e9dia do aluno \u00e9 \" + media ); if ( media >= 6 ) { Console . WriteLine ( \"O aluno esta aprovado!\" ); } else { Console . WriteLine ( \"O aluno esta reprovado!\" ); } } } } F\u00e1cil n\u00e3o? Vamos dar mais um grau de dificuldade: Agora a escola que utiliza este programa mudou a forma de aprova\u00e7\u00e3o e reprova\u00e7\u00e3o do aluno. Agora deve ser: Se o aluno estiver m\u00e9dia 7 ou maior, ele esta aprovado; E se o aluno estiver com m\u00e9dia entre 5 e 6, ele esta de recupera\u00e7\u00e3o; Mas se a m\u00e9dia estiver menor que 5, ele esta reprovado. Parece complicado? Vamos ver no c\u00f3digo: using System ; namespace CalculaMedia { class Program { static void Main ( string [] args ) { Console . Write ( \"Digite a primeira nota do aluno: \" ); int nota1 = int . Parse ( Console . ReadLine ()); Console . Write ( \"Digite a segunda nota do aluno: \" ); int nota2 = int . Parse ( Console . ReadLine ()); int media = ( nota1 + nota2 ) / 2 ; Console . WriteLine ( \"A m\u00e9dia do aluno \u00e9 \" + media ); if ( media >= 7 ) { Console . WriteLine ( \"O aluno esta aprovado!\" ); } else if ( media >= 5 ) { Console . WriteLine ( \"O aluno esta em recupera\u00e7\u00e3o!\" ); } else { Console . WriteLine ( \"O aluno esta reprovado!\" ); } } } } Switch case \u00b6 Utilizando este tipo de condicional, o que define a decis\u00e3o \u00e9 um teste onde trabalhamos com algumas possibilidades de resposta. Vamos resolver o seguinte problema: Desenvolver um programa que leia uma op\u00e7\u00e3o (um n\u00famero inteiro) do usu\u00e1rio e as op\u00e7\u00f5es devem ser: Caso op\u00e7\u00e3o 1: Imprimir \"Ol\u00e1 mundo\"; Caso op\u00e7\u00e3o 2: Imprimir \"At\u00e9 mais mundo\"; Caso op\u00e7\u00e3o 3: Imprimir \"Boa noite mundo\"; Caso qualquer outra op\u00e7\u00e3o: Imprimir \"Digite somente op\u00e7\u00f5es 1, 2 ou 3\". O c\u00f3digo seria mais ou menos assim: using System ; namespace VerificaOpcoes { class Program { static void Main ( string [] args ) { Console . Write ( \"Digite uma op\u00e7\u00e3o: \" ); int opcao = int . Parse ( Console . ReadLine ()); switch ( opcao ) { case 1 : Console . WriteLine ( \"Ol\u00e1 mundo\" ); break ; case 2 : Console . WriteLine ( \"At\u00e9 mais mundo\" ); break ; case 3 : Console . WriteLine ( \"Boa noite mundo\" ); break ; default : Console . WriteLine ( \"Digite somente op\u00e7\u00f5es 1, 2 ou 3\" ); break ; } } } } C# 7 Quick Syntax Reference: A Pocket Guide to the Language, APIs, and Library \u21a9","title":"Condicionais"},{"location":"dotnet/basics/conditionals/#condicionais","text":"Os condicionais s\u00e3o momentos de decis\u00e3o em um programa onde ele pode ou n\u00e3o executar um peda\u00e7o do c\u00f3digo 1 . Esta decis\u00e3o pode ser desenvolvida de duas formas: If/else/else if (Se/sen\u00e3o/sen\u00e3o se) Switch case (Em caso de)","title":"Condicionais"},{"location":"dotnet/basics/conditionals/#ifelseelse-if","text":"Utilizando este tipo de condicional, o que define a decis\u00e3o \u00e9 um teste onde a resposta precisa ser booleano, isto \u00e9, precisa retornar verdadeiro ou falso. Ent\u00e3o vamos a mais um problema que temos que resolver desenvolvendo um programa em C#: Criar um programa que calcule a m\u00e9dia aritm\u00e9tica de duas notas (n\u00fameros inteiros) de um aluno e imprima a m\u00e9dia e se esta m\u00e9dia for maior ou igual a 6 imprimir \"aprovado\". O c\u00f3digo ficaria mais ou menos assim: using System ; namespace CalculaMedia { class Program { static void Main ( string [] args ) { Console . Write ( \"Digite a primeira nota do aluno: \" ); int nota1 = int . Parse ( Console . ReadLine ()); Console . Write ( \"Digite a segunda nota do aluno: \" ); int nota2 = int . Parse ( Console . ReadLine ()); int media = ( nota1 + nota2 ) / 2 ; Console . WriteLine ( \"A m\u00e9dia do aluno \u00e9 \" + media ); if ( media >= 6 ) { Console . WriteLine ( \"O aluno esta aprovado!\" ); } } } } Adicionando uma regra nova: O programa precisa retornar alem de \"aprovado\" quando for maior ou igual a 6 a nota, deve retornar \"reprovado\" quando for o contrario. Para isso vamos fazer as modifica\u00e7\u00f5es: using System ; namespace CalculaMedia { class Program { static void Main ( string [] args ) { Console . Write ( \"Digite a primeira nota do aluno: \" ); int nota1 = int . Parse ( Console . ReadLine ()); Console . Write ( \"Digite a segunda nota do aluno: \" ); int nota2 = int . Parse ( Console . ReadLine ()); int media = ( nota1 + nota2 ) / 2 ; Console . WriteLine ( \"A m\u00e9dia do aluno \u00e9 \" + media ); if ( media >= 6 ) { Console . WriteLine ( \"O aluno esta aprovado!\" ); } else { Console . WriteLine ( \"O aluno esta reprovado!\" ); } } } } F\u00e1cil n\u00e3o? Vamos dar mais um grau de dificuldade: Agora a escola que utiliza este programa mudou a forma de aprova\u00e7\u00e3o e reprova\u00e7\u00e3o do aluno. Agora deve ser: Se o aluno estiver m\u00e9dia 7 ou maior, ele esta aprovado; E se o aluno estiver com m\u00e9dia entre 5 e 6, ele esta de recupera\u00e7\u00e3o; Mas se a m\u00e9dia estiver menor que 5, ele esta reprovado. Parece complicado? Vamos ver no c\u00f3digo: using System ; namespace CalculaMedia { class Program { static void Main ( string [] args ) { Console . Write ( \"Digite a primeira nota do aluno: \" ); int nota1 = int . Parse ( Console . ReadLine ()); Console . Write ( \"Digite a segunda nota do aluno: \" ); int nota2 = int . Parse ( Console . ReadLine ()); int media = ( nota1 + nota2 ) / 2 ; Console . WriteLine ( \"A m\u00e9dia do aluno \u00e9 \" + media ); if ( media >= 7 ) { Console . WriteLine ( \"O aluno esta aprovado!\" ); } else if ( media >= 5 ) { Console . WriteLine ( \"O aluno esta em recupera\u00e7\u00e3o!\" ); } else { Console . WriteLine ( \"O aluno esta reprovado!\" ); } } } }","title":"If/else/else if"},{"location":"dotnet/basics/conditionals/#switch-case","text":"Utilizando este tipo de condicional, o que define a decis\u00e3o \u00e9 um teste onde trabalhamos com algumas possibilidades de resposta. Vamos resolver o seguinte problema: Desenvolver um programa que leia uma op\u00e7\u00e3o (um n\u00famero inteiro) do usu\u00e1rio e as op\u00e7\u00f5es devem ser: Caso op\u00e7\u00e3o 1: Imprimir \"Ol\u00e1 mundo\"; Caso op\u00e7\u00e3o 2: Imprimir \"At\u00e9 mais mundo\"; Caso op\u00e7\u00e3o 3: Imprimir \"Boa noite mundo\"; Caso qualquer outra op\u00e7\u00e3o: Imprimir \"Digite somente op\u00e7\u00f5es 1, 2 ou 3\". O c\u00f3digo seria mais ou menos assim: using System ; namespace VerificaOpcoes { class Program { static void Main ( string [] args ) { Console . Write ( \"Digite uma op\u00e7\u00e3o: \" ); int opcao = int . Parse ( Console . ReadLine ()); switch ( opcao ) { case 1 : Console . WriteLine ( \"Ol\u00e1 mundo\" ); break ; case 2 : Console . WriteLine ( \"At\u00e9 mais mundo\" ); break ; case 3 : Console . WriteLine ( \"Boa noite mundo\" ); break ; default : Console . WriteLine ( \"Digite somente op\u00e7\u00f5es 1, 2 ou 3\" ); break ; } } } } C# 7 Quick Syntax Reference: A Pocket Guide to the Language, APIs, and Library \u21a9","title":"Switch case"},{"location":"dotnet/basics/looping/","text":"Repeti\u00e7\u00f5es \u00b6 As repeti\u00e7\u00f5es s\u00e3o trechos de c\u00f3digo que ser\u00e3o repetidos durante uma determinada condi\u00e7\u00e3o 1 . Temos os seguintes tipos de repeti\u00e7\u00f5es: For (Para) While (Enquanto) Do while (Fa\u00e7a enquanto) Foreach (Para cada) Vamos usar o mesmo problema em cada um dos tipos de repeti\u00e7\u00f5es: Fazer um programa que imprima os n\u00fameros de 1 (inclusive) a 10 (inclusive). Vamos ver em cada tipo como vamos resolver este problema. For \u00b6 Vamos ao c\u00f3digo: using System ; namespace ListaNumeros { class Program { static void Main ( string [] args ) { for ( int i = 1 ; i <= 10 ; i ++) { Console . WriteLine ( i ); } } } } Quando usamos o for , ele cria uma vari\u00e1vel do tipo inteira que ser\u00e1 nossa vari\u00e1vel de intera\u00e7\u00e3o. Ela recebe um n\u00famero novo a cada vez que passamos no c\u00f3digo e ele ir\u00e1 repetir at\u00e9 que a condi\u00e7\u00e3o desejada n\u00e3o possa ser mais aceita. Podemos ver isso no trecho entre parenteses int i = 1; i <= 10; i++ , onde: int i = 1; cria nossa vari\u00e1vel de intera\u00e7\u00e3o e inicia com o n\u00famero 1; i <= 10; \u00e9 nosso condicional. Enquanto a vari\u00e1vel i for menor ou igual a 10, ele ir\u00e1 repetir o que esta dentro das chaves do for , neste caso, Console.WriteLine(i); ; i++ \u00e9 um operador de incremento que representa o mesmo que i = i + 1 . While \u00b6 Vamos ao c\u00f3digo do mesmo problema, s\u00f3 que agora com o while : using System ; namespace ListaNumeros { class Program { static void Main ( string [] args ) { int i = 1 ; while ( i <= 10 ) { Console . WriteLine ( i ); i ++; } } } } Se repararem temos os mesmos 3 elementos que usamos no for , s\u00f3 que tivemos que inicializar fora do while a vari\u00e1vel e incrementar ela dentro das chaves do while . Este n\u00e3o \u00e9 o melhor exemplo de uso de um while, que deve ser usado, por exemplo, quando n\u00e3o temos uma leitura ordenada de valores. Do while \u00b6 O c\u00f3digo n\u00e3o muda muito do while : using System ; namespace ListaNumeros { class Program { static void Main ( string [] args ) { int i = 1 ; do { Console . WriteLine ( i ); i ++; } while ( i <= 10 ); } } } Em resumo, um coloca um while em cima e outro em baixo?!?? Exatamente! Neste caso, mesmo que o la\u00e7o nunca fosse executado, por exemplo, se o int i fosse igual a 15, ele iria imprimir o n\u00famero 15, pois no do while ele executa primeiro e verifica depois. Um exemplo que funcionaria melhor para o caso do do while seria abrir um programa que deve ficar em execu\u00e7\u00e3o at\u00e9 que o usu\u00e1rio diga que quer encerrar o programa. Foreach \u00b6 Este tipo de repeti\u00e7\u00e3o \u00e9 usada quando temos uma vari\u00e1vel que seja uma lista ou um vetor . Vamos ver o c\u00f3digo: using System ; namespace ListaNumeros { class Program { static void Main ( string [] args ) { int [] numeros = new int [ 10 ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 }; foreach ( var numero in numeros ) { Console . WriteLine ( numero ); } } } } O foreach \u00e9 o mais \"diferent\u00e3o\" dos tipos de repeti\u00e7\u00e3o. Isso porque como j\u00e1 foi comentado ele precisa de uma lista ou de um vetor , algo que seja enumer\u00e1vel. Este tipo de repeti\u00e7\u00e3o \u00e9 o mais utilizado no desenvolvimento de aplica\u00e7\u00f5es mais complexas, onde temos que tratar de dados enumer\u00e1veis. C# 7 Quick Syntax Reference: A Pocket Guide to the Language, APIs, and Library \u21a9","title":"Repeti\u00e7\u00f5es"},{"location":"dotnet/basics/looping/#repeticoes","text":"As repeti\u00e7\u00f5es s\u00e3o trechos de c\u00f3digo que ser\u00e3o repetidos durante uma determinada condi\u00e7\u00e3o 1 . Temos os seguintes tipos de repeti\u00e7\u00f5es: For (Para) While (Enquanto) Do while (Fa\u00e7a enquanto) Foreach (Para cada) Vamos usar o mesmo problema em cada um dos tipos de repeti\u00e7\u00f5es: Fazer um programa que imprima os n\u00fameros de 1 (inclusive) a 10 (inclusive). Vamos ver em cada tipo como vamos resolver este problema.","title":"Repeti\u00e7\u00f5es"},{"location":"dotnet/basics/looping/#for","text":"Vamos ao c\u00f3digo: using System ; namespace ListaNumeros { class Program { static void Main ( string [] args ) { for ( int i = 1 ; i <= 10 ; i ++) { Console . WriteLine ( i ); } } } } Quando usamos o for , ele cria uma vari\u00e1vel do tipo inteira que ser\u00e1 nossa vari\u00e1vel de intera\u00e7\u00e3o. Ela recebe um n\u00famero novo a cada vez que passamos no c\u00f3digo e ele ir\u00e1 repetir at\u00e9 que a condi\u00e7\u00e3o desejada n\u00e3o possa ser mais aceita. Podemos ver isso no trecho entre parenteses int i = 1; i <= 10; i++ , onde: int i = 1; cria nossa vari\u00e1vel de intera\u00e7\u00e3o e inicia com o n\u00famero 1; i <= 10; \u00e9 nosso condicional. Enquanto a vari\u00e1vel i for menor ou igual a 10, ele ir\u00e1 repetir o que esta dentro das chaves do for , neste caso, Console.WriteLine(i); ; i++ \u00e9 um operador de incremento que representa o mesmo que i = i + 1 .","title":"For"},{"location":"dotnet/basics/looping/#while","text":"Vamos ao c\u00f3digo do mesmo problema, s\u00f3 que agora com o while : using System ; namespace ListaNumeros { class Program { static void Main ( string [] args ) { int i = 1 ; while ( i <= 10 ) { Console . WriteLine ( i ); i ++; } } } } Se repararem temos os mesmos 3 elementos que usamos no for , s\u00f3 que tivemos que inicializar fora do while a vari\u00e1vel e incrementar ela dentro das chaves do while . Este n\u00e3o \u00e9 o melhor exemplo de uso de um while, que deve ser usado, por exemplo, quando n\u00e3o temos uma leitura ordenada de valores.","title":"While"},{"location":"dotnet/basics/looping/#do-while","text":"O c\u00f3digo n\u00e3o muda muito do while : using System ; namespace ListaNumeros { class Program { static void Main ( string [] args ) { int i = 1 ; do { Console . WriteLine ( i ); i ++; } while ( i <= 10 ); } } } Em resumo, um coloca um while em cima e outro em baixo?!?? Exatamente! Neste caso, mesmo que o la\u00e7o nunca fosse executado, por exemplo, se o int i fosse igual a 15, ele iria imprimir o n\u00famero 15, pois no do while ele executa primeiro e verifica depois. Um exemplo que funcionaria melhor para o caso do do while seria abrir um programa que deve ficar em execu\u00e7\u00e3o at\u00e9 que o usu\u00e1rio diga que quer encerrar o programa.","title":"Do while"},{"location":"dotnet/basics/looping/#foreach","text":"Este tipo de repeti\u00e7\u00e3o \u00e9 usada quando temos uma vari\u00e1vel que seja uma lista ou um vetor . Vamos ver o c\u00f3digo: using System ; namespace ListaNumeros { class Program { static void Main ( string [] args ) { int [] numeros = new int [ 10 ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 }; foreach ( var numero in numeros ) { Console . WriteLine ( numero ); } } } } O foreach \u00e9 o mais \"diferent\u00e3o\" dos tipos de repeti\u00e7\u00e3o. Isso porque como j\u00e1 foi comentado ele precisa de uma lista ou de um vetor , algo que seja enumer\u00e1vel. Este tipo de repeti\u00e7\u00e3o \u00e9 o mais utilizado no desenvolvimento de aplica\u00e7\u00f5es mais complexas, onde temos que tratar de dados enumer\u00e1veis. C# 7 Quick Syntax Reference: A Pocket Guide to the Language, APIs, and Library \u21a9","title":"Foreach"},{"location":"dotnet/basics/operators/","text":"Operadores \u00b6 Os operadores s\u00e3o s\u00edmbolos especiais para operar valores 1 . Eles podem ser: Aritm\u00e9ticos Atribui\u00e7\u00e3o Compara\u00e7\u00e3o L\u00f3gicos Operadores Aritm\u00e9ticos \u00b6 S\u00e3o os operadores das quatro opera\u00e7\u00f5es matem\u00e1ticas b\u00e1sicas e o operador de m\u00f3dulo . Segue abaixo o uso no c\u00f3digo: int x = 3 + 2 ; // adi\u00e7\u00e3o x = 3 - 2 ; // subtra\u00e7\u00e3o x = 3 * 2 ; // multiplica\u00e7\u00e3o x = 3 / 2 ; // divis\u00e3o x = 3 % 2 ; // m\u00f3dulo (resto da divis\u00e3o) Operador de Atribui\u00e7\u00e3o \u00b6 O operador de atribui\u00e7\u00e3o mais usado \u00e9 o = que representa o a atribui\u00e7\u00e3o de valor a uma vari\u00e1vel. Operadores de Atribui\u00e7\u00e3o Combinados \u00b6 Um uso comum dos operadores de atribui\u00e7\u00e3o e aritm\u00e9ticos combinados \u00e9 quando queremos executar um calculo simples com a vari\u00e1vel que precisa retornar para ela mesma. Vejam um exemplo de uso no c\u00f3digo: int x = 0 ; x += 5 ; // x = x + 5; x -= 5 ; // x = x - 5; x *= 5 ; // x = x * 5; x /= 5 ; // x = x / 5; x %= 5 ; // x = x % 5; Operadores de Incremento e Decremento \u00b6 Outro operador comum \u00e9 quando queremos fazer um simples incremento (somar 1) ou um simples decremento (subtrair 1) de uma vari\u00e1vel. Veja o exemplo no c\u00f3digo: x ++; // x = x + 1; x --; // x = x - 1; Estes operadores podem ser usados antes ou depois da v\u00e1riavel: x ++; // p\u00f3s-incremento x --; // p\u00f3s-decremento ++ x ; // pr\u00e9-incremento -- x ; // pr\u00e9-decremento Embora pare\u00e7am a mesma coisa, existe uma diferen\u00e7a do pr\u00e9 e no p\u00f3s incremento ou decremento. Vamos resolver um problema e ver o que acontece em cada um dos casos: Desenvolver um programa que leia um n\u00famero e imprima o n\u00famero digitado e o pr\u00f3ximo n\u00famero. Para isso vamos ver este c\u00f3digo: using System ; namespace ImprimeProximoNumero { class Program { static void Main ( string [] args ) { Console . Write ( \"Digite um n\u00famero: \" ); int numero = int . Parse ( Console . ReadLine ()); Console . WriteLine ( \"O n\u00famero digitado foi: \" + numero ++); Console . WriteLine ( \"O pr\u00f3ximo n\u00famero \u00e9: \" + numero ); } } } A execu\u00e7\u00e3o deste c\u00f3digo temos: Agora se alterarmos o c\u00f3digo para este: using System ; namespace ImprimeProximoNumero { class Program { static void Main ( string [] args ) { Console . Write ( \"Digite um n\u00famero: \" ); int numero = int . Parse ( Console . ReadLine ()); Console . WriteLine ( \"O n\u00famero digitado foi: \" + ++ numero ); Console . WriteLine ( \"O pr\u00f3ximo n\u00famero \u00e9: \" + numero ); } } } A execu\u00e7\u00e3o acontece assim: Repare que o n\u00famero digitado j\u00e1 somou na mesma linha onde ele estava antes de imprimir o resultado! Operadores de Compara\u00e7\u00e3o \u00b6 Operadores de compara\u00e7\u00e3o retornam sempre verdadeiro ( true ) ou falso ( false ). S\u00e3o usados sempre que precisamos de uma condi\u00e7\u00e3o a ser atendida (como em Condicionais ou em Repeti\u00e7\u00f5es ). Veja os exemplos no c\u00f3digo abaixo: bool b = ( 2 == 3 ); // igual \u00e1 b = ( 2 != 3 ); // diferente de b = ( 2 > 3 ); // maior que b = ( 2 < 3 ); // menor que b = ( 2 >= 3 ); // maior ou igual \u00e1 b = ( 2 <= 3 ); // menor ou igual \u00e1 Operadores L\u00f3gicos \u00b6 Os operadores l\u00f3gicos s\u00e3o usados em conjunto com os operadores de compara\u00e7\u00e3o para comparar um conjunto de booleanos. Veja os exemplos no c\u00f3digo abaixo: bool b = ( true && false ); // operador \"e\" l\u00f3gico b = ( true || false ); // operador \"ou\" l\u00f3gico b = !( true ); // operador \"n\u00e3o\" l\u00f3gico Temos mais operadores 1 , mas de forma b\u00e1sica estes s\u00e3o os mais usados. C# 7 Quick Syntax Reference: A Pocket Guide to the Language, APIs, and Library \u21a9 \u21a9","title":"Operadores"},{"location":"dotnet/basics/operators/#operadores","text":"Os operadores s\u00e3o s\u00edmbolos especiais para operar valores 1 . Eles podem ser: Aritm\u00e9ticos Atribui\u00e7\u00e3o Compara\u00e7\u00e3o L\u00f3gicos","title":"Operadores"},{"location":"dotnet/basics/operators/#operadores-aritmeticos","text":"S\u00e3o os operadores das quatro opera\u00e7\u00f5es matem\u00e1ticas b\u00e1sicas e o operador de m\u00f3dulo . Segue abaixo o uso no c\u00f3digo: int x = 3 + 2 ; // adi\u00e7\u00e3o x = 3 - 2 ; // subtra\u00e7\u00e3o x = 3 * 2 ; // multiplica\u00e7\u00e3o x = 3 / 2 ; // divis\u00e3o x = 3 % 2 ; // m\u00f3dulo (resto da divis\u00e3o)","title":"Operadores Aritm\u00e9ticos"},{"location":"dotnet/basics/operators/#operador-de-atribuicao","text":"O operador de atribui\u00e7\u00e3o mais usado \u00e9 o = que representa o a atribui\u00e7\u00e3o de valor a uma vari\u00e1vel.","title":"Operador de Atribui\u00e7\u00e3o"},{"location":"dotnet/basics/operators/#operadores-de-atribuicao-combinados","text":"Um uso comum dos operadores de atribui\u00e7\u00e3o e aritm\u00e9ticos combinados \u00e9 quando queremos executar um calculo simples com a vari\u00e1vel que precisa retornar para ela mesma. Vejam um exemplo de uso no c\u00f3digo: int x = 0 ; x += 5 ; // x = x + 5; x -= 5 ; // x = x - 5; x *= 5 ; // x = x * 5; x /= 5 ; // x = x / 5; x %= 5 ; // x = x % 5;","title":"Operadores de Atribui\u00e7\u00e3o Combinados"},{"location":"dotnet/basics/operators/#operadores-de-incremento-e-decremento","text":"Outro operador comum \u00e9 quando queremos fazer um simples incremento (somar 1) ou um simples decremento (subtrair 1) de uma vari\u00e1vel. Veja o exemplo no c\u00f3digo: x ++; // x = x + 1; x --; // x = x - 1; Estes operadores podem ser usados antes ou depois da v\u00e1riavel: x ++; // p\u00f3s-incremento x --; // p\u00f3s-decremento ++ x ; // pr\u00e9-incremento -- x ; // pr\u00e9-decremento Embora pare\u00e7am a mesma coisa, existe uma diferen\u00e7a do pr\u00e9 e no p\u00f3s incremento ou decremento. Vamos resolver um problema e ver o que acontece em cada um dos casos: Desenvolver um programa que leia um n\u00famero e imprima o n\u00famero digitado e o pr\u00f3ximo n\u00famero. Para isso vamos ver este c\u00f3digo: using System ; namespace ImprimeProximoNumero { class Program { static void Main ( string [] args ) { Console . Write ( \"Digite um n\u00famero: \" ); int numero = int . Parse ( Console . ReadLine ()); Console . WriteLine ( \"O n\u00famero digitado foi: \" + numero ++); Console . WriteLine ( \"O pr\u00f3ximo n\u00famero \u00e9: \" + numero ); } } } A execu\u00e7\u00e3o deste c\u00f3digo temos: Agora se alterarmos o c\u00f3digo para este: using System ; namespace ImprimeProximoNumero { class Program { static void Main ( string [] args ) { Console . Write ( \"Digite um n\u00famero: \" ); int numero = int . Parse ( Console . ReadLine ()); Console . WriteLine ( \"O n\u00famero digitado foi: \" + ++ numero ); Console . WriteLine ( \"O pr\u00f3ximo n\u00famero \u00e9: \" + numero ); } } } A execu\u00e7\u00e3o acontece assim: Repare que o n\u00famero digitado j\u00e1 somou na mesma linha onde ele estava antes de imprimir o resultado!","title":"Operadores de Incremento e Decremento"},{"location":"dotnet/basics/operators/#operadores-de-comparacao","text":"Operadores de compara\u00e7\u00e3o retornam sempre verdadeiro ( true ) ou falso ( false ). S\u00e3o usados sempre que precisamos de uma condi\u00e7\u00e3o a ser atendida (como em Condicionais ou em Repeti\u00e7\u00f5es ). Veja os exemplos no c\u00f3digo abaixo: bool b = ( 2 == 3 ); // igual \u00e1 b = ( 2 != 3 ); // diferente de b = ( 2 > 3 ); // maior que b = ( 2 < 3 ); // menor que b = ( 2 >= 3 ); // maior ou igual \u00e1 b = ( 2 <= 3 ); // menor ou igual \u00e1","title":"Operadores de Compara\u00e7\u00e3o"},{"location":"dotnet/basics/operators/#operadores-logicos","text":"Os operadores l\u00f3gicos s\u00e3o usados em conjunto com os operadores de compara\u00e7\u00e3o para comparar um conjunto de booleanos. Veja os exemplos no c\u00f3digo abaixo: bool b = ( true && false ); // operador \"e\" l\u00f3gico b = ( true || false ); // operador \"ou\" l\u00f3gico b = !( true ); // operador \"n\u00e3o\" l\u00f3gico Temos mais operadores 1 , mas de forma b\u00e1sica estes s\u00e3o os mais usados. C# 7 Quick Syntax Reference: A Pocket Guide to the Language, APIs, and Library \u21a9 \u21a9","title":"Operadores L\u00f3gicos"},{"location":"dotnet/basics/variables/","text":"Vari\u00e1veis \u00b6 A partir de agora vamos come\u00e7ar a brincar com o exemplo do Mais que um Hello World (Ol\u00e1 Mundo) para entendermos o que s\u00e3o as vari\u00e1veis no C#. Para isso vamos a um problema: Precisamos de um programa que escreva mais do que um simples \" Hello World \". Agora ele deve escrever: \"Ol\u00e1 Luiz\" onde \"Luiz\" deve ser o nome do programador armazenado em uma vari\u00e1vel. Mas, vamos do principio: O que \u00e9 uma vari\u00e1vel? Vari\u00e1vel \u00e9 uma \u00e1rea de mem\u00f3ria tempor\u00e1ria onde podemos armazenar um determinado dado enquanto o programa esta sendo executado. Este dado pode ser do tipo: string: Valores alfanum\u00e9ricos; Exemplo: string nome = \"Luiz\"; int: N\u00fameros inteiros; Exemplo: int idade = 38; double: \"N\u00fameros com virgula\"; Exemplo: double preco = 19.99; bool: Valores booleanos (Verdadeiro ou Falso). Exemplo: bool comprado = true; Existem outros tipos de dados 1 , mas vamos trabalhar inicialmente com estes. Ok, vamos voltar ao problema: Escrever \"Ol\u00e1 Luiz\", onde \"Luiz\" \u00e9 um dado armazenado em uma vari\u00e1vel. Ent\u00e3o podemos fazer assim: using System ; namespace HelloWorld { class Program { static void Main ( string [] args ) { string nome = \"Luiz\" ; Console . WriteLine ( \"Ol\u00e1 \" + nome ); } } } Execute este c\u00f3digo e altere o valor da vari\u00e1vel. F\u00e1cil n\u00e3o? Entenda que o \"Ol\u00e1 \" + nome \u00e9 uma concatena\u00e7\u00e3o de strings. \u00c9 como se estiv\u00e9ssemos escrevendo \"Ol\u00e1 \" + \"Luiz\" . Ent\u00e3o vamos come\u00e7ar a deixar mais complexo. Vamos pedir para que o usu\u00e1rio (a pessoa que esta executando nosso programa), para que digite o nome dela e depois imprima o \"Ol\u00e1 nome-que-a-pessoa-digitou\". \ud83d\ude05 Este pode ser feito usando um outro m\u00e9todo do objeto Console , o ReadLine() . Vamos ver o uso dele na resolu\u00e7\u00e3o do problema abaixo: using System ; namespace HelloWorld { class Program { static void Main ( string [] args ) { Console . Write ( \"Digite o seu nome: \" ); string nome = Console . ReadLine (); Console . WriteLine ( \"Ol\u00e1 \" + nome ); } } } Neste exemplo podemos ver o uso de duas coisas: Mais um m\u00e9todo do objeto Console chamado Write() . A diferen\u00e7a destes m\u00e9todo com o WriteLine() \u00e9 que ele n\u00e3o \"avan\u00e7a para a linha de baixo\", como se tiv\u00e9ssemos teclado <Enter>. Ele fica com o cursor na mesma linha. O uso da do Console.ReadLine() manda o valor digitado para uma vari\u00e1vel, no caso aproveitei a vari\u00e1vel do tipo string que hav\u00edamos criado. Somado ao m\u00e9todo Write() na linha de cima, criei um efeito de escrever na mesma linha onde ele faz a pergunta \"Digite o seu nome: \". Veja a execu\u00e7\u00e3o no terminal abaixo: Agora que aprendemos alguns comandos legais, vamos complicar um pouco mais. O problema a resolver agora \u00e9 criar um programa que calcule a m\u00e9dia aritm\u00e9tica de duas notas (n\u00fameros inteiros) de um aluno. Para isso vou criar um projeto novo chamado \"CalculaMedia\". Porque? Porque isso que representa um projeto: Um novo programa! Ent\u00e3o vou fazer os mesmos passos que vimos em Mais que um Hello World (Ol\u00e1 Mundo) . using System ; namespace CalculaMedia { class Program { static void Main ( string [] args ) { Console . Write ( \"Digite a primeira nota do aluno: \" ); int nota1 = int . Parse ( Console . ReadLine ()); Console . Write ( \"Digite a segunda nota do aluno: \" ); int nota2 = int . Parse ( Console . ReadLine ()); int media = ( nota1 + nota2 ) / 2 ; Console . WriteLine ( \"A m\u00e9dia do aluno \u00e9 \" + media ); } } } Opa! Agora come\u00e7ou a vir coisas novas! Vamos l\u00e1: Apareceu um cara novo: int.Parse() . Como o tipo inteiro ( int ) que nos permite fazer c\u00e1lculos (string n\u00e3o fazem c\u00e1lculos, eles concatenam lembra?), e o tipo inteiro n\u00e3o \u00e9 \"compreens\u00edvel\" com o tipo string (como disse, um concatena e outro calcula), ent\u00e3o precisamos converter o formato. E \u00e9 para isso que serve o int.Parse() . O m\u00e9todo ReadLine() sempre retorna o dado em formato string, isto \u00e9, se voc\u00ea digitar um n\u00famero, ele vai criar uma string com este n\u00famero. Para fixar essa ideia: string nota1 = \"5\"; \u00e9 um texto, diferente de int nota1 = 5; que \u00e9 um n\u00famero. Podemos ver a formula da m\u00e9dia na vari\u00e1vel do tipo inteira chamada media . Esta formula precisa dos valores que o usu\u00e1rio vai digitar nas vari\u00e1veis nota1 e nota2 . Veja a execu\u00e7\u00e3o no terminal abaixo: C# 7 Quick Syntax Reference: A Pocket Guide to the Language, APIs, and Library \u21a9","title":"Vari\u00e1veis"},{"location":"dotnet/basics/variables/#variaveis","text":"A partir de agora vamos come\u00e7ar a brincar com o exemplo do Mais que um Hello World (Ol\u00e1 Mundo) para entendermos o que s\u00e3o as vari\u00e1veis no C#. Para isso vamos a um problema: Precisamos de um programa que escreva mais do que um simples \" Hello World \". Agora ele deve escrever: \"Ol\u00e1 Luiz\" onde \"Luiz\" deve ser o nome do programador armazenado em uma vari\u00e1vel. Mas, vamos do principio: O que \u00e9 uma vari\u00e1vel? Vari\u00e1vel \u00e9 uma \u00e1rea de mem\u00f3ria tempor\u00e1ria onde podemos armazenar um determinado dado enquanto o programa esta sendo executado. Este dado pode ser do tipo: string: Valores alfanum\u00e9ricos; Exemplo: string nome = \"Luiz\"; int: N\u00fameros inteiros; Exemplo: int idade = 38; double: \"N\u00fameros com virgula\"; Exemplo: double preco = 19.99; bool: Valores booleanos (Verdadeiro ou Falso). Exemplo: bool comprado = true; Existem outros tipos de dados 1 , mas vamos trabalhar inicialmente com estes. Ok, vamos voltar ao problema: Escrever \"Ol\u00e1 Luiz\", onde \"Luiz\" \u00e9 um dado armazenado em uma vari\u00e1vel. Ent\u00e3o podemos fazer assim: using System ; namespace HelloWorld { class Program { static void Main ( string [] args ) { string nome = \"Luiz\" ; Console . WriteLine ( \"Ol\u00e1 \" + nome ); } } } Execute este c\u00f3digo e altere o valor da vari\u00e1vel. F\u00e1cil n\u00e3o? Entenda que o \"Ol\u00e1 \" + nome \u00e9 uma concatena\u00e7\u00e3o de strings. \u00c9 como se estiv\u00e9ssemos escrevendo \"Ol\u00e1 \" + \"Luiz\" . Ent\u00e3o vamos come\u00e7ar a deixar mais complexo. Vamos pedir para que o usu\u00e1rio (a pessoa que esta executando nosso programa), para que digite o nome dela e depois imprima o \"Ol\u00e1 nome-que-a-pessoa-digitou\". \ud83d\ude05 Este pode ser feito usando um outro m\u00e9todo do objeto Console , o ReadLine() . Vamos ver o uso dele na resolu\u00e7\u00e3o do problema abaixo: using System ; namespace HelloWorld { class Program { static void Main ( string [] args ) { Console . Write ( \"Digite o seu nome: \" ); string nome = Console . ReadLine (); Console . WriteLine ( \"Ol\u00e1 \" + nome ); } } } Neste exemplo podemos ver o uso de duas coisas: Mais um m\u00e9todo do objeto Console chamado Write() . A diferen\u00e7a destes m\u00e9todo com o WriteLine() \u00e9 que ele n\u00e3o \"avan\u00e7a para a linha de baixo\", como se tiv\u00e9ssemos teclado <Enter>. Ele fica com o cursor na mesma linha. O uso da do Console.ReadLine() manda o valor digitado para uma vari\u00e1vel, no caso aproveitei a vari\u00e1vel do tipo string que hav\u00edamos criado. Somado ao m\u00e9todo Write() na linha de cima, criei um efeito de escrever na mesma linha onde ele faz a pergunta \"Digite o seu nome: \". Veja a execu\u00e7\u00e3o no terminal abaixo: Agora que aprendemos alguns comandos legais, vamos complicar um pouco mais. O problema a resolver agora \u00e9 criar um programa que calcule a m\u00e9dia aritm\u00e9tica de duas notas (n\u00fameros inteiros) de um aluno. Para isso vou criar um projeto novo chamado \"CalculaMedia\". Porque? Porque isso que representa um projeto: Um novo programa! Ent\u00e3o vou fazer os mesmos passos que vimos em Mais que um Hello World (Ol\u00e1 Mundo) . using System ; namespace CalculaMedia { class Program { static void Main ( string [] args ) { Console . Write ( \"Digite a primeira nota do aluno: \" ); int nota1 = int . Parse ( Console . ReadLine ()); Console . Write ( \"Digite a segunda nota do aluno: \" ); int nota2 = int . Parse ( Console . ReadLine ()); int media = ( nota1 + nota2 ) / 2 ; Console . WriteLine ( \"A m\u00e9dia do aluno \u00e9 \" + media ); } } } Opa! Agora come\u00e7ou a vir coisas novas! Vamos l\u00e1: Apareceu um cara novo: int.Parse() . Como o tipo inteiro ( int ) que nos permite fazer c\u00e1lculos (string n\u00e3o fazem c\u00e1lculos, eles concatenam lembra?), e o tipo inteiro n\u00e3o \u00e9 \"compreens\u00edvel\" com o tipo string (como disse, um concatena e outro calcula), ent\u00e3o precisamos converter o formato. E \u00e9 para isso que serve o int.Parse() . O m\u00e9todo ReadLine() sempre retorna o dado em formato string, isto \u00e9, se voc\u00ea digitar um n\u00famero, ele vai criar uma string com este n\u00famero. Para fixar essa ideia: string nota1 = \"5\"; \u00e9 um texto, diferente de int nota1 = 5; que \u00e9 um n\u00famero. Podemos ver a formula da m\u00e9dia na vari\u00e1vel do tipo inteira chamada media . Esta formula precisa dos valores que o usu\u00e1rio vai digitar nas vari\u00e1veis nota1 e nota2 . Veja a execu\u00e7\u00e3o no terminal abaixo: C# 7 Quick Syntax Reference: A Pocket Guide to the Language, APIs, and Library \u21a9","title":"Vari\u00e1veis"},{"location":"dotnet/orientacao-a-objetos/","text":"Programa\u00e7\u00e3o Orientada a objetos \u00b6 A programa\u00e7\u00e3o orientada a objetos nos tr\u00e1s a analogia de objetos do mundo real. Vejam o exemplo onde podemos desenvolver um jogo de corrida e os objetos do mundo real que usamos em um carro de corrida ser utilizado nesta programa\u00e7\u00e3o como o piloto, o carro, os pneus, o volante, e por a\u00ed vai 1 ! Classe e objetos \u00b6 Ent\u00e3o, qualquer coisa que tenha propriedades e pode realizar a\u00e7\u00f5es s\u00e3o considerados como objetos. Agora antes de sair criando nossos objetos na programa\u00e7\u00e3o \u00e9 necess\u00e1rio entender a diferen\u00e7a entre classes e objetos 1 . Classe : Podemos comparar com uma planta baixa, ou um template de um futuro objeto. \u00c9 na classe que escrevemos as propriedades e os m\u00e9todos que um objeto vai utilizar. Vale lembrar que uma classe n\u00e3o ocupa espa\u00e7o em mem\u00f3ria! Objeto : O objeto \u00e9 algo que ocupa espa\u00e7o em mem\u00f3ria e \u00e9 inicializado a partir de uma classe. Podemos comparar como a constru\u00e7\u00e3o de uma casa (o objeto) a partir se sua planta baixa (a classe). Propriedades \u00b6 S\u00e3o as caracter\u00edsticas que um objeto pode ter. No exemplo do objeto carro, as propriedades podem ser o pa\u00eds de constru\u00e7\u00e3o, ano de fabrica\u00e7\u00e3o, a marca, o modelo, etc 1 . Vamos ver a classe Carro em C#: using System ; namespace ExemploOO { public class Carro { public string Pais ; public int Ano ; public string Modelo ; public string Marca ; } } M\u00e9todos \u00b6 S\u00e3o as a\u00e7\u00f5es que este objeto poder\u00e1 executar 1 . Continuando com o exemplo da classe Carro em C# onde adicionaremos alguns m\u00e9todos: using System ; namespace ExemploOO { public class Carro { public string Pais ; public int Ano ; public string Modelo ; public string Marca ; public void Ligar () { Console . WriteLine ( \"Carro ligado.\" ); } public void Desligar () { Console . WriteLine ( \"Carro desligado.\" ); } public void Andar () { Console . WriteLine ( \"O carro esta andando.\" ); } public void Parar () { Console . WriteLine ( \"O carro esta parado.\" ); } } } Inst\u00e2nciando um objeto \u00b6 Como foi comentado em Classes e Objetos , uma classe n\u00e3o ocupa espa\u00e7o em mem\u00f3ria e um objeto, ao contr\u00e1rio, ocupa. Para que uma classe se torne um objeto, temos que fazer sua inst\u00e2ncia (o inicializa\u00e7\u00e3o) como objeto. Para isso, vamos inicializar a classe Carro no arquivo Program.cs : using System ; using System.Threading ; namespace ExemploOO { class Program { static void Main ( string [] args ) { Carro c = new Carro (); // A partir daqui temos o objeto c do tipo Carro // Colocando as propriedades c . Pais = \"Alemanha\" ; c . Ano = 2007 ; c . Modelo = \"BMW M3 Coup\u00e9\" ; c . Marca = \"BMW\" ; Console . WriteLine ( \"Carro: {0} {1}/{2} - {3}\" , c . Modelo , c . Ano , c . Marca , c . Pais ); // Executando os m\u00e9todos c . Ligar (); c . Andar (); // Dando uma pausa de 2 segundos para o carro andar Thread . Sleep ( 2000 ); c . Parar (); c . Desligar (); } } } Podemos ver a execu\u00e7\u00e3o do nosso primeiro objeto, em um programa, abaixo: Construtores \u00b6 Um construtor \u00e9 um m\u00e9todo especial que \u00e9 executado no momento de sua inicializa\u00e7\u00e3o e para cria-lo, devemos criar um m\u00e9todo com o mesmo nome da classe 1 . Vamos criar um construtor para nossa classe Carro : using System ; namespace ExemploOO { public class Carro { public string Pais ; public int Ano ; public string Modelo ; public string Marca ; public Carro () // Este \u00e9 um construtor { // Quando o objeto for inicializado, ele j\u00e1 ir\u00e1 ter // estas informa\u00e7\u00f5es como propriedades. this . Pais = \"Alemanha\" ; this . Ano = 2011 ; this . Modelo = \"BMW Z4 GT3\" ; this . Marca = \"BMW\" ; } public void Ligar () { Console . WriteLine ( \"Carro ligado.\" ); } public void Desligar () { Console . WriteLine ( \"Carro desligado.\" ); } public void Andar () { Console . WriteLine ( \"O carro esta andando.\" ); } public void Parar () { Console . WriteLine ( \"O carro esta parado.\" ); } } } Vamos ver a execu\u00e7\u00e3o desta nova classe alterando nosso Program.cs : using System ; using System.Threading ; namespace ExemploOO { class Program { static void Main ( string [] args ) { Carro c = new Carro (); // A partir daqui temos o objeto c do tipo Carro // Reparem que n\u00e3o foi inserida nenhuma propriedade! Console . WriteLine ( \"Carro: {0} {1}/{2} - {3}\" , c . Modelo , c . Ano , c . Marca , c . Pais ); // Executando os m\u00e9todos c . Ligar (); c . Andar (); // Dando uma pausa de 2 segundos para o carro andar Thread . Sleep ( 2000 ); c . Parar (); c . Desligar (); } } } Em execu\u00e7\u00e3o, temos o seguinte resultado: Encapsulamento \u00b6 Encapsulamento representa a prote\u00e7\u00e3o de alguma forma os trechos de c\u00f3digo de um objeto afim de ser acess\u00edvel somente de quem tem permiss\u00e3o. Em C# chamamos de modificadores de acesso e usamos isso desde o item Orienta\u00e7\u00e3o a Objetos , isto \u00e9, o public que escrevemos antes de cada classe, propriedade ou m\u00e9todo. Temos 5 valores poss\u00edveis de usar e est\u00e3o apresentados na tabela abaixo 1 : Modificador Funcionalidade public Acess\u00edvel em qualquer classe private Acess\u00edvel apenas na classe que foi declarado protected Acess\u00edvel apenas a classe que foi declarado e suas subclasses internal Acess\u00edvel \u00e0s classes dentro do mesmo assembly ou assembly associado protected-internal Efeito combinado de protected e internal Heran\u00e7a \u00b6 Como todos os conceitos apresentados at\u00e9 aqui sobre orienta\u00e7\u00e3o a objetos, a heran\u00e7a tamb\u00e9m \u00e9 algo que \u00e9 similar ao mundo real. Uma crian\u00e7a herda tra\u00e7os do seus pais ao mesmo tempo que possui suas pr\u00f3prias caracter\u00edsticas. Na programa\u00e7\u00e3o a ideia segue o mesmo conceito, onde um objeto poder herdar propriedades e m\u00e9todos de outro objeto que chamamos de \"objeto pai\". Ent\u00e3o um objeto Carro e Caminhao esta para um objeto pai chamado Veiculo . Vamos ver o exemplo abaixo destas classes: Arquivo Veiculo.cs : using System ; namespace ExemploOO { public class Veiculo { public string Pais ; public int Ano ; public string Modelo ; public string Marca ; public void Ligar () { Console . WriteLine ( \"Ve\u00edculo ligado.\" ); } public void Desligar () { Console . WriteLine ( \"Ve\u00edculo desligado.\" ); } public void Andar () { Console . WriteLine ( \"O ve\u00edculo esta andando.\" ); } public void Parar () { Console . WriteLine ( \"O ve\u00edculo esta parado.\" ); } } } Arquivo Carro.cs : namespace ExemploOO { // Aqui temos a heran\u00e7a sendo adicionada, agora Carro \u00e9 herdeiro de Veiculo public class Carro : Veiculo { public Carro ( string marca , string modelo , int ano , string pais ) { // \"this\" quer dizer a pr\u00f3pria classe mas ela n\u00e3o tem a // propriedade \"Pais\". Na realidade sua classe pai que // passou essa propriedade (uma heran\u00e7a) para Carro! this . Pais = pais ; this . Ano = ano ; this . Modelo = modelo ; this . Marca = marca ; } } } Arquivo Caminhao.cs : namespace ExemploOO { // Aqui temos a heran\u00e7a sendo adicionada, agora Caminhao \u00e9 herdeiro de Veiculo public class Caminhao : Veiculo { public Caminhao ( string marca , string modelo , int ano ) { // \"this\" quer dizer a pr\u00f3pria classe mas ela n\u00e3o tem a // propriedade \"Ano\". Na realidade sua classe pai que // passou essa propriedade (uma heran\u00e7a) para Caminhao! this . Ano = ano ; this . Modelo = modelo ; this . Marca = marca ; } } } E aqui um exemplo de uso dos objetos usando a heran\u00e7a no Program.cs : using System ; using System.Threading ; namespace ExemploOO { class Program { static void Main ( string [] args ) { Carro c = new Carro ( \"Aston Martin\" , \"DB11\" , 2016 , \"Inglaterra\" ); Caminhao t = new Caminhao ( \"Volvo\" , \"FH16\" , 2009 ); Console . WriteLine ( \"\\nCarro: {0} {1}/{2} - {3}\" , c . Modelo , c . Ano , c . Marca , c . Pais ); c . Ligar (); c . Andar (); Thread . Sleep ( 2000 ); c . Parar (); c . Desligar (); Console . WriteLine ( \"\\nCaminhao {0} {1}/{2}\" , t . Modelo , t . Ano , t . Marca ); c . Ligar (); c . Andar (); Thread . Sleep ( 2000 ); c . Parar (); c . Desligar (); } } } Aqui a execu\u00e7\u00e3o deste programa: Polimorfismo \u00b6 O polimorfismo tem como base a ideia que na classe pai, temos um m\u00e9todo e este mesmo m\u00e9todo existe na classe filha e \u00e9 sobrescrito 1 . Imagine o nosso caso anterior, das classes filhas Carro e Caminhao , onde pode se ver que os m\u00e9todos Ligar() , Andar() , Parar() e Desligar() eram da classe pai, mas executamos eles normalmente nas classes filhas devido a ser uma heran\u00e7a. Mas e quando um destes m\u00e9todos precisa ser diferente em uma determinada classe filha? Por exemplo, o carro que ao andar agora pode habilitar o uso do turbo. Como isso ficaria? Os arquivos Veiculo.cs e Caminhao.cs permanecem iguais, nossa mudan\u00e7a ser\u00e1 em Carro.cs : using System ; namespace ExemploOO { // Aqui temos a heran\u00e7a sendo adicionada, agora Carro \u00e9 herdeiro de Veiculo public class Carro : Veiculo { public Carro ( string marca , string modelo , int ano , string pais ) { // \"this\" quer dizer a pr\u00f3pria classe mas ela n\u00e3o tem a // propriedade \"Pais\". Na realidade sua classe pai que // passou essa propriedade (uma heran\u00e7a) para Carro! this . Pais = pais ; this . Ano = ano ; this . Modelo = modelo ; this . Marca = marca ; } public void Andar ( bool usaTurbo ) { if ( usaTurbo ) { Console . WriteLine ( \"O ve\u00edculo esta correndo.\" ); } else { Console . WriteLine ( \"O ve\u00edculo esta andando.\" ); } } } } E no arquivo Program.cs : using System ; using System.Threading ; namespace ExemploOO { class Program { static void Main ( string [] args ) { Carro c = new Carro ( \"Aston Martin\" , \"DB11\" , 2016 , \"Inglaterra\" ); Caminhao t = new Caminhao ( \"Volvo\" , \"FH16\" , 2009 ); Console . WriteLine ( \"\\nCarro: {0} {1}/{2} - {3}\" , c . Modelo , c . Ano , c . Marca , c . Pais ); c . Ligar (); c . Andar ( false ); Thread . Sleep ( 2000 ); c . Andar ( true ); Thread . Sleep ( 2000 ); c . Parar (); c . Desligar (); Console . WriteLine ( \"\\nCaminhao {0} {1}/{2}\" , t . Modelo , t . Ano , t . Marca ); c . Ligar (); c . Andar (); Thread . Sleep ( 2000 ); c . Parar (); c . Desligar (); } } } Podemos ver que a execu\u00e7\u00e3o ficou um pouco diferente: Programa\u00e7\u00e3o em C# Para Iniciantes \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9","title":"Programa\u00e7\u00e3o Orientada a objetos"},{"location":"dotnet/orientacao-a-objetos/#programacao-orientada-a-objetos","text":"A programa\u00e7\u00e3o orientada a objetos nos tr\u00e1s a analogia de objetos do mundo real. Vejam o exemplo onde podemos desenvolver um jogo de corrida e os objetos do mundo real que usamos em um carro de corrida ser utilizado nesta programa\u00e7\u00e3o como o piloto, o carro, os pneus, o volante, e por a\u00ed vai 1 !","title":"Programa\u00e7\u00e3o Orientada a objetos"},{"location":"dotnet/orientacao-a-objetos/#classe-e-objetos","text":"Ent\u00e3o, qualquer coisa que tenha propriedades e pode realizar a\u00e7\u00f5es s\u00e3o considerados como objetos. Agora antes de sair criando nossos objetos na programa\u00e7\u00e3o \u00e9 necess\u00e1rio entender a diferen\u00e7a entre classes e objetos 1 . Classe : Podemos comparar com uma planta baixa, ou um template de um futuro objeto. \u00c9 na classe que escrevemos as propriedades e os m\u00e9todos que um objeto vai utilizar. Vale lembrar que uma classe n\u00e3o ocupa espa\u00e7o em mem\u00f3ria! Objeto : O objeto \u00e9 algo que ocupa espa\u00e7o em mem\u00f3ria e \u00e9 inicializado a partir de uma classe. Podemos comparar como a constru\u00e7\u00e3o de uma casa (o objeto) a partir se sua planta baixa (a classe).","title":"Classe e objetos"},{"location":"dotnet/orientacao-a-objetos/#propriedades","text":"S\u00e3o as caracter\u00edsticas que um objeto pode ter. No exemplo do objeto carro, as propriedades podem ser o pa\u00eds de constru\u00e7\u00e3o, ano de fabrica\u00e7\u00e3o, a marca, o modelo, etc 1 . Vamos ver a classe Carro em C#: using System ; namespace ExemploOO { public class Carro { public string Pais ; public int Ano ; public string Modelo ; public string Marca ; } }","title":"Propriedades"},{"location":"dotnet/orientacao-a-objetos/#metodos","text":"S\u00e3o as a\u00e7\u00f5es que este objeto poder\u00e1 executar 1 . Continuando com o exemplo da classe Carro em C# onde adicionaremos alguns m\u00e9todos: using System ; namespace ExemploOO { public class Carro { public string Pais ; public int Ano ; public string Modelo ; public string Marca ; public void Ligar () { Console . WriteLine ( \"Carro ligado.\" ); } public void Desligar () { Console . WriteLine ( \"Carro desligado.\" ); } public void Andar () { Console . WriteLine ( \"O carro esta andando.\" ); } public void Parar () { Console . WriteLine ( \"O carro esta parado.\" ); } } }","title":"M\u00e9todos"},{"location":"dotnet/orientacao-a-objetos/#instanciando-um-objeto","text":"Como foi comentado em Classes e Objetos , uma classe n\u00e3o ocupa espa\u00e7o em mem\u00f3ria e um objeto, ao contr\u00e1rio, ocupa. Para que uma classe se torne um objeto, temos que fazer sua inst\u00e2ncia (o inicializa\u00e7\u00e3o) como objeto. Para isso, vamos inicializar a classe Carro no arquivo Program.cs : using System ; using System.Threading ; namespace ExemploOO { class Program { static void Main ( string [] args ) { Carro c = new Carro (); // A partir daqui temos o objeto c do tipo Carro // Colocando as propriedades c . Pais = \"Alemanha\" ; c . Ano = 2007 ; c . Modelo = \"BMW M3 Coup\u00e9\" ; c . Marca = \"BMW\" ; Console . WriteLine ( \"Carro: {0} {1}/{2} - {3}\" , c . Modelo , c . Ano , c . Marca , c . Pais ); // Executando os m\u00e9todos c . Ligar (); c . Andar (); // Dando uma pausa de 2 segundos para o carro andar Thread . Sleep ( 2000 ); c . Parar (); c . Desligar (); } } } Podemos ver a execu\u00e7\u00e3o do nosso primeiro objeto, em um programa, abaixo:","title":"Inst\u00e2nciando um objeto"},{"location":"dotnet/orientacao-a-objetos/#construtores","text":"Um construtor \u00e9 um m\u00e9todo especial que \u00e9 executado no momento de sua inicializa\u00e7\u00e3o e para cria-lo, devemos criar um m\u00e9todo com o mesmo nome da classe 1 . Vamos criar um construtor para nossa classe Carro : using System ; namespace ExemploOO { public class Carro { public string Pais ; public int Ano ; public string Modelo ; public string Marca ; public Carro () // Este \u00e9 um construtor { // Quando o objeto for inicializado, ele j\u00e1 ir\u00e1 ter // estas informa\u00e7\u00f5es como propriedades. this . Pais = \"Alemanha\" ; this . Ano = 2011 ; this . Modelo = \"BMW Z4 GT3\" ; this . Marca = \"BMW\" ; } public void Ligar () { Console . WriteLine ( \"Carro ligado.\" ); } public void Desligar () { Console . WriteLine ( \"Carro desligado.\" ); } public void Andar () { Console . WriteLine ( \"O carro esta andando.\" ); } public void Parar () { Console . WriteLine ( \"O carro esta parado.\" ); } } } Vamos ver a execu\u00e7\u00e3o desta nova classe alterando nosso Program.cs : using System ; using System.Threading ; namespace ExemploOO { class Program { static void Main ( string [] args ) { Carro c = new Carro (); // A partir daqui temos o objeto c do tipo Carro // Reparem que n\u00e3o foi inserida nenhuma propriedade! Console . WriteLine ( \"Carro: {0} {1}/{2} - {3}\" , c . Modelo , c . Ano , c . Marca , c . Pais ); // Executando os m\u00e9todos c . Ligar (); c . Andar (); // Dando uma pausa de 2 segundos para o carro andar Thread . Sleep ( 2000 ); c . Parar (); c . Desligar (); } } } Em execu\u00e7\u00e3o, temos o seguinte resultado:","title":"Construtores"},{"location":"dotnet/orientacao-a-objetos/#encapsulamento","text":"Encapsulamento representa a prote\u00e7\u00e3o de alguma forma os trechos de c\u00f3digo de um objeto afim de ser acess\u00edvel somente de quem tem permiss\u00e3o. Em C# chamamos de modificadores de acesso e usamos isso desde o item Orienta\u00e7\u00e3o a Objetos , isto \u00e9, o public que escrevemos antes de cada classe, propriedade ou m\u00e9todo. Temos 5 valores poss\u00edveis de usar e est\u00e3o apresentados na tabela abaixo 1 : Modificador Funcionalidade public Acess\u00edvel em qualquer classe private Acess\u00edvel apenas na classe que foi declarado protected Acess\u00edvel apenas a classe que foi declarado e suas subclasses internal Acess\u00edvel \u00e0s classes dentro do mesmo assembly ou assembly associado protected-internal Efeito combinado de protected e internal","title":"Encapsulamento"},{"location":"dotnet/orientacao-a-objetos/#heranca","text":"Como todos os conceitos apresentados at\u00e9 aqui sobre orienta\u00e7\u00e3o a objetos, a heran\u00e7a tamb\u00e9m \u00e9 algo que \u00e9 similar ao mundo real. Uma crian\u00e7a herda tra\u00e7os do seus pais ao mesmo tempo que possui suas pr\u00f3prias caracter\u00edsticas. Na programa\u00e7\u00e3o a ideia segue o mesmo conceito, onde um objeto poder herdar propriedades e m\u00e9todos de outro objeto que chamamos de \"objeto pai\". Ent\u00e3o um objeto Carro e Caminhao esta para um objeto pai chamado Veiculo . Vamos ver o exemplo abaixo destas classes: Arquivo Veiculo.cs : using System ; namespace ExemploOO { public class Veiculo { public string Pais ; public int Ano ; public string Modelo ; public string Marca ; public void Ligar () { Console . WriteLine ( \"Ve\u00edculo ligado.\" ); } public void Desligar () { Console . WriteLine ( \"Ve\u00edculo desligado.\" ); } public void Andar () { Console . WriteLine ( \"O ve\u00edculo esta andando.\" ); } public void Parar () { Console . WriteLine ( \"O ve\u00edculo esta parado.\" ); } } } Arquivo Carro.cs : namespace ExemploOO { // Aqui temos a heran\u00e7a sendo adicionada, agora Carro \u00e9 herdeiro de Veiculo public class Carro : Veiculo { public Carro ( string marca , string modelo , int ano , string pais ) { // \"this\" quer dizer a pr\u00f3pria classe mas ela n\u00e3o tem a // propriedade \"Pais\". Na realidade sua classe pai que // passou essa propriedade (uma heran\u00e7a) para Carro! this . Pais = pais ; this . Ano = ano ; this . Modelo = modelo ; this . Marca = marca ; } } } Arquivo Caminhao.cs : namespace ExemploOO { // Aqui temos a heran\u00e7a sendo adicionada, agora Caminhao \u00e9 herdeiro de Veiculo public class Caminhao : Veiculo { public Caminhao ( string marca , string modelo , int ano ) { // \"this\" quer dizer a pr\u00f3pria classe mas ela n\u00e3o tem a // propriedade \"Ano\". Na realidade sua classe pai que // passou essa propriedade (uma heran\u00e7a) para Caminhao! this . Ano = ano ; this . Modelo = modelo ; this . Marca = marca ; } } } E aqui um exemplo de uso dos objetos usando a heran\u00e7a no Program.cs : using System ; using System.Threading ; namespace ExemploOO { class Program { static void Main ( string [] args ) { Carro c = new Carro ( \"Aston Martin\" , \"DB11\" , 2016 , \"Inglaterra\" ); Caminhao t = new Caminhao ( \"Volvo\" , \"FH16\" , 2009 ); Console . WriteLine ( \"\\nCarro: {0} {1}/{2} - {3}\" , c . Modelo , c . Ano , c . Marca , c . Pais ); c . Ligar (); c . Andar (); Thread . Sleep ( 2000 ); c . Parar (); c . Desligar (); Console . WriteLine ( \"\\nCaminhao {0} {1}/{2}\" , t . Modelo , t . Ano , t . Marca ); c . Ligar (); c . Andar (); Thread . Sleep ( 2000 ); c . Parar (); c . Desligar (); } } } Aqui a execu\u00e7\u00e3o deste programa:","title":"Heran\u00e7a"},{"location":"dotnet/orientacao-a-objetos/#polimorfismo","text":"O polimorfismo tem como base a ideia que na classe pai, temos um m\u00e9todo e este mesmo m\u00e9todo existe na classe filha e \u00e9 sobrescrito 1 . Imagine o nosso caso anterior, das classes filhas Carro e Caminhao , onde pode se ver que os m\u00e9todos Ligar() , Andar() , Parar() e Desligar() eram da classe pai, mas executamos eles normalmente nas classes filhas devido a ser uma heran\u00e7a. Mas e quando um destes m\u00e9todos precisa ser diferente em uma determinada classe filha? Por exemplo, o carro que ao andar agora pode habilitar o uso do turbo. Como isso ficaria? Os arquivos Veiculo.cs e Caminhao.cs permanecem iguais, nossa mudan\u00e7a ser\u00e1 em Carro.cs : using System ; namespace ExemploOO { // Aqui temos a heran\u00e7a sendo adicionada, agora Carro \u00e9 herdeiro de Veiculo public class Carro : Veiculo { public Carro ( string marca , string modelo , int ano , string pais ) { // \"this\" quer dizer a pr\u00f3pria classe mas ela n\u00e3o tem a // propriedade \"Pais\". Na realidade sua classe pai que // passou essa propriedade (uma heran\u00e7a) para Carro! this . Pais = pais ; this . Ano = ano ; this . Modelo = modelo ; this . Marca = marca ; } public void Andar ( bool usaTurbo ) { if ( usaTurbo ) { Console . WriteLine ( \"O ve\u00edculo esta correndo.\" ); } else { Console . WriteLine ( \"O ve\u00edculo esta andando.\" ); } } } } E no arquivo Program.cs : using System ; using System.Threading ; namespace ExemploOO { class Program { static void Main ( string [] args ) { Carro c = new Carro ( \"Aston Martin\" , \"DB11\" , 2016 , \"Inglaterra\" ); Caminhao t = new Caminhao ( \"Volvo\" , \"FH16\" , 2009 ); Console . WriteLine ( \"\\nCarro: {0} {1}/{2} - {3}\" , c . Modelo , c . Ano , c . Marca , c . Pais ); c . Ligar (); c . Andar ( false ); Thread . Sleep ( 2000 ); c . Andar ( true ); Thread . Sleep ( 2000 ); c . Parar (); c . Desligar (); Console . WriteLine ( \"\\nCaminhao {0} {1}/{2}\" , t . Modelo , t . Ano , t . Marca ); c . Ligar (); c . Andar (); Thread . Sleep ( 2000 ); c . Parar (); c . Desligar (); } } } Podemos ver que a execu\u00e7\u00e3o ficou um pouco diferente: Programa\u00e7\u00e3o em C# Para Iniciantes \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9","title":"Polimorfismo"}]}